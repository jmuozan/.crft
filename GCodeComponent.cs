using System;
using System.Collections.Generic;
using System.Drawing;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;
using Rhino.Geometry;

namespace crft
{
    /// <summary>
    /// Generates G-code toolpaths from slicing contours.
    /// </summary>
    public class GCodeComponent : GH_Component
    {
        public GCodeComponent()
          : base("gcode", "gcode",
              "Generate G-code from slicing contours",
              "crft", "Generation")
        {
        }

        protected override void RegisterInputParams(GH_InputParamManager p)
        {
            p.AddCurveParameter("Contours", "C", "Contour curves per layer", GH_ParamAccess.tree);
            p.AddNumberParameter("First Layer Height", "F", "First layer height (mm)", GH_ParamAccess.item, 0.2);
            p.AddNumberParameter("Layer Height", "L", "Layer height (mm)", GH_ParamAccess.item, 0.2);
            p.AddNumberParameter("Print Speed", "S", "Print speed (mm/s)", GH_ParamAccess.item, 60.0);
            p.AddNumberParameter("Flow", "E", "Extrusion multiplier", GH_ParamAccess.item, 1.0);
            p.AddBooleanParameter("Optimize", "O", "Optimize path order per layer", GH_ParamAccess.item, false);
        }

        protected override void RegisterOutputParams(GH_OutputParamManager p)
        {
            p.AddTextParameter("G-Code", "G", "Generated G-code", GH_ParamAccess.list);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            // Gather inputs
            GH_Structure<GH_Curve> contours = null;
            double firstLayerHeight = 0.2;
            double layerHeight = 0.2;
            double printSpeed = 60.0;
            double flow = 1.0;
            bool optimize = false;

            if (!DA.GetDataTree(0, out contours)) return;
            DA.GetData(1, ref firstLayerHeight);
            DA.GetData(2, ref layerHeight);
            DA.GetData(3, ref printSpeed);
            DA.GetData(4, ref flow);
            DA.GetData(5, ref optimize);

            // Prepare G-code header
            var gcode = new List<string>()
            {
                "; G-code generated by crft gcode",
                $"; {DateTime.Now:yyyy-MM-dd HH:mm:ss}",
                "G28 ; Home all axes",
                "G90 ; Absolute positioning",
                "M82 ; Absolute extrusion"
            };

            // Iterate layers
            for (int pi = 0; pi < contours.Paths.Count; pi++)
            {
                var path = contours.Paths[pi];
                int layer = path.Indices.Length > 0 ? path.Indices[0] : pi;
                double z = firstLayerHeight + layer * layerHeight;
                gcode.Add($"; Layer {layer + 1} at Z={z:F3}");
                gcode.Add($"G1 Z{z:F3} F{printSpeed * 60:F0}");

                // Build list of polylines
                var polys = new List<Polyline>();
                foreach (var ghc in contours.Branches[pi])
                {
                    var plc = ghc.Value.ToPolyline(0.01, 0.1, 0.1, 100);
                    if (plc != null && plc.TryGetPolyline(out Polyline poly) && poly.Count > 1)
                        polys.Add(poly);
                }

                // Optional path optimization (nearest-neighbor)
                if (optimize && polys.Count > 1)
                {
                    var ordered = new List<Polyline> { polys[0] };
                    var remaining = new List<Polyline>(polys);
                    remaining.RemoveAt(0);
                    while (remaining.Count > 0)
                    {
                        var last = ordered[ordered.Count - 1];
                        int bestIdx = 0;
                        double bestDist = double.MaxValue;
                        for (int i = 0; i < remaining.Count; i++)
                        {
                            double d = last[last.Count - 1].DistanceTo(remaining[i][0]);
                            if (d < bestDist) { bestDist = d; bestIdx = i; }
                        }
                        ordered.Add(remaining[bestIdx]);
                        remaining.RemoveAt(bestIdx);
                    }
                    polys = ordered;
                }

                // Emit G-code for each polyline
                foreach (var poly in polys)
                {
                    gcode.Add($"G0 X{poly[0].X:F3} Y{poly[0].Y:F3} F{printSpeed * 60:F0}");
                    gcode.Add($"G1 F{printSpeed * 60:F0}");
                    double eTotal = 0;
                    for (int i = 1; i < poly.Count; i++)
                    {
                        double d = poly[i - 1].DistanceTo(poly[i]);
                        eTotal += d * flow;
                        gcode.Add($"G1 X{poly[i].X:F3} Y{poly[i].Y:F3} E{eTotal:F5}");
                    }
                }
            }

            // Footer
            gcode.Add("M84 ; Disable motors");
            DA.SetDataList(0, gcode);
        }

        protected override Bitmap Icon => null;
        public override Guid ComponentGuid => new Guid("2E150B59-109A-4E6C-A606-FA65A4FE1BE1");
    }
}